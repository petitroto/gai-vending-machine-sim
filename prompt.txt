自動販売機シミュレーターのプログラムを書いてください。三連引用符で囲んだ仕様を漏れなく満たしてください。

"""
### 自動販売機シミュレーターのUI ###
以下の要素を画面に表示する。
* 自動販売機シミュレーターのタイトル
* 各商品の購入ボタン（商品名と価格を表示）
* 残高表示パネル
* 100円を投入するボタン
* お釣り返却ボタン
* 商品の取り出し口
* お釣りの返却口

### 商品と価格 ###
* コーヒー : 100円
* コーラ : 100円
* 紅茶 : 100円
* ジュース : 100円
* 水 : 100円

### 自動販売機の状態の種類と初期値 ###
* 各商品の在庫数 : いずれの商品も3本ずつ
* 預かり金の残高 : 0円
* イベントバッファ : 空配列
* 最終操作時刻 : 現在時刻
* 会話履歴 : 空配列（型はChat Completions APIの「messages」と同じ）

### 自動販売機の状態に基づくUIの更新 ###
自動販売機の状態が変わったら、UIの各要素の表示を以下のように更新する。
* 各商品の購入ボタン :
  1. 残高があって商品の在庫もある場合 : 緑色で押せる
  2. 残高があるけど商品の在庫がない場合 : 赤色で押せない
  3. 残高がない場合 : 白色で押せない
* 残高表示パネル : 常にその時点の残高が表示される
* お釣り返却ボタン : 残高があれば押せる。残高がなければ押せない。
* 商品の取り出し口 : 商品が購入されたらその商品名が表示される。それ以外の場合は何も表示されない
* お釣りの返却口 : お釣りが返却されたら、返却された金額が表示される。それ以外の場合は何も表示されない

### キーボードからのキーイベントの処理 ###
以下のキーボードのキーから指が離されたら、そのキーに対応する自動販売機のボタンが１回押されたものとして処理する。
* 「1」キー : コーヒーの購入ボタン
* 「2」キー : コーラの購入ボタン
* 「3」キー : 紅茶の購入ボタン
* 「4」キー : ジュースの購入ボタン
* 「5」キー : 水の購入ボタン
* 「6」キー : 100円を投入するボタン
* 「7」キー : お釣り返却ボタン
購入ボタンにも、対応するキーの番号を表示してください。

### 操作イベントの記録 ###
以下のボタンかキーの操作が行われたら、対応する操作イベント名をイベントバッファに格納する。また、最終操作時刻を現在時刻に更新する。自動販売機APIの呼び出しは行わない。
* コーヒーの購入ボタンか「1」キーを押し下げた : PushBuyCoffee
* コーラの購入ボタンか「2」キーを押し下げた : PushBuyCola
* 紅茶の購入ボタンか「3」キーを押し下げた : PushBuyTea
* ジュースの購入ボタンか「4」キーを押し下げた : PushBuyJuice
* 水の購入ボタンか「5」キーを押し下げた : PushBuyWater
* 100円を投入するボタンか「6」キーを押し下げた : Insert100YenCoin
* お釣り返却ボタンか「7」キーを押し下げた : PushReturnChange

### 自動販売機API ###
AIアシスタントからのみ呼び出し可能な関数として以下のAPIを実装する。
* 入金 : 残高を100円増やす
* 購入 : 指定した商品を取り出し口から排出し、残高を100円減らす
* 返却 : 残高をお釣りの返却口から返却し、残高を0円にする
* 再生 : 指定したメッセージを音声で読み上げる（Web Speech APIのSpeechSynthesis関数を使う）

### AIアシスタントによる自動販売機の操作 ###
最終操作時刻から１秒以上経過しているかどうかを１秒おきにチェックする。もし経過していたら以下の処理を実行する。
* OpenAIのChat Completions APIへ送信するuserのメッセージオブジェクトを作成する。メッセージには、ユーザーが今回行った操作（イベントバッファの内容）と、操作後の預かり金の残高と、操作後の商品ごとの在庫数を含める。
* userのメッセージオブジェクトを会話履歴の最後に追加する
* イベントバッファを空っぽにする
* サーバー側プログラムのアシスタントAPIへ、HTTP POSTで会話履歴を送信して、messageオブジェクトを受け取る
* messageオブジェクトをJSON文字列にしたものをcontentに設定したassistantのメッセージを、会話履歴の最後に追加する。
* messageオブジェクトのtool_callsプロパティに関数の情報が含まれていれば、それに対応する自動販売機APIの関数を実行する

### デバッグコンソールのUI ###
以下の要素を画面に表示する。要素の大きさは固定する。
* 操作イベントバッファ表示パネル
* 通信状態表示パネル
* 会話ログ表示パネル

### デバッグコンソールの更新 ###
* イベントバッファ表示パネル : イベントバッファに変化があったら、最新のイベントバッファの内容に更新する
* 通信状態表示パネル : サーバー側プログラムのAPIの応答を待っている時は「通信中」と表示し、そうでなければ何も表示しない
* 会話ログ表示パネル : 会話履歴に変化があれば、最新の会話履歴の内容に更新する

### サーバー側プログラム ###
ブラウザでルートパスにアクセスすると、クライアントのHTMLを応答する。また、以下の仕様のアシスタントAPIを提供する。
* 会話履歴を受け取って、会話履歴の先頭に「自動販売機のシステムプロンプト」を付けて、メッセージ配列を作る
* OpenAIのChat Completions APIに送信して応答を受け取る。以下のパラメータを指定する
  model = gpt-4-turbo-preview
  messages = メッセージ配列
  tools = 自動販売機APIの全ての関数のスキーマ
* Chat Completions APIの応答のうち、choicesのmessageプロパティの値（messageオブジェクト）をクライアント側へ返す

### 自動販売機のシステムプロンプト ###
サーバー側プロンプトがChat Completions APIに送信するシステムプロンプトは、以下の通りです。
「あなたは自動販売機です。ユーザーが行った操作と自動販売機の状態を受け取って、自動販売機が実行するべき機能を応答してください。購入や返却の機能は、ユーザーが行った操作が「通常の使い方」と判断できる場合のみ実行してください。ユーザーが行った操作が「異常な使い方」と判断した場合は、購入や返却の機能は実行せず、適切な案内のメッセージを再生してください。応答は日本語でお願いします。」

### Chat Completions APIへの要求のパラメータ「messages」の例 ###
roleとcontentの値は文字列型。
```
messages: [
  {"role": "system", "content": "You are a helpful assistant."},
  {"role": "user", "content": "Knock knock."},
  {"role": "assistant", "content": "Who's there?"},
  {"role": "user", "content": "Orange."}
]
```

### Chat Completions APIへの要求のパラメータ「tools」の例 ###
parametersの値の書式はJSON Schemaに従う。
```
tools: [
  {
    "type": "function",
    "function": {
      "name": "get_current_weather",
      "description": "Get the current weather in a given location",
      "parameters": {
        "type": "object",
        "properties": {
          "location": {
            "type": "string",
            "description": "The city and state, e.g. San Francisco, CA"
          },
          "unit": {
            "type": "string",
            "enum": [
              "celsius",
              "fahrenheit"
            ]
          }
        },
        "required": [
          "location"
        ]
      }
    }
  }
]
```

### Chat Completions APIの応答のプロパティ「tool_calls」の例 ###
```
[
  {
    "id": "call_abc123",
    "type": "function",
    "function": {
      "name": "get_current_weather",
      "arguments": "{\n\"location\": \"Boston, MA\"\n}"
    }
  }
]
```
"""

クライアント側は、Webブラウザ単体で動作するHTMLアプリケーションとして出力してください。
サーバー側は、Node.jsで動作するJavaScriptプログラムとして出力してください。

まずはクライアント側を出力してください。クライアント側の通信モジュールはfetchを利用してください。指示があるまでサーバー側は出力しないでください。

↑↑↑↑↑↑↑ 最初に入力するのはここまで ↑↑↑↑↑↑↑

↓↓↓↓↓↓↓ 必要に応じて以下の入力を繰り返す ↓↓↓↓↓↓↓

このコードは与えた仕様を漏れなく満たすか確認してください。もし不足している仕様があれば修正してください。

↓↓↓↓↓↓↓ 品質が十分になったら次に以下の入力をする ↓↓↓↓↓↓↓

次にサーバー側を出力してください。サーバー側の通信モジュールはaxiosを利用してください。環境変数はdotenvを使用して設定可能にしてください。

↓↓↓↓↓↓↓ 必要に応じて以下の入力を繰り返す ↓↓↓↓↓↓↓

このコードは与えた仕様を漏れなく満たすか確認してください。もし不足している仕様があれば修正してください。
